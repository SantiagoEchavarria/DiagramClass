<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>Diagrama de clases</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
   

  </head>
  <body>    
    <div id="root"></div>
    <canvas id="myCanvas" width="1280" height="600"></canvas>
    <button id="startDrawingButton" class="btn btn-primary">Iniciar Dibujo</button>
    <button id="deleteArrowButton" class="btn btn-danger" style="display: none;">Eliminar Flecha</button>

    
    <script >
      const canvas = document.getElementById('myCanvas');
      const ctx = canvas.getContext('2d');
      const deleteArrowButton = document.getElementById('deleteArrowButton');
      let isDrawing = false;
      let drawingEnabled = false;
      let startX, startY, currentX, currentY;
      let selectedArrowIndex = -1;
      let arrows = []; // Inicialización de la variable arrows
      
      // Esperar a que se presione el botón para iniciar el dibujo
      document.getElementById('startDrawingButton').addEventListener('click', () => {
          drawingEnabled = true; // Habilita el dibujo
          canvas.style.display = 'block'; // Mostrar el canvas
      
          // Añadir eventos si no están ya añadidos
          if (!canvas.hasEventListeners) {
              canvas.addEventListener('mousedown', onMouseDown);
              canvas.addEventListener('mousemove', onMouseMove);
              canvas.addEventListener('mouseup', onMouseUp);
              canvas.addEventListener('mouseout', onMouseOut);
              canvas.addEventListener('click', onCanvasClick);
              canvas.hasEventListeners = true; // Marca el canvas como teniendo eventos
          }
      });
      
      // Maneja clics en el botón de eliminar
      deleteArrowButton.addEventListener('click', () => {
          if (selectedArrowIndex > -1) {
              arrows.splice(selectedArrowIndex, 1);
              drawArrows();
              selectedArrowIndex = -1;
              deleteArrowButton.style.display = 'none';
          }
      });
      
      function onMouseDown(e) {
          if (drawingEnabled) {
              isDrawing = true;
              startX = e.offsetX;
              startY = e.offsetY;
          }
      }
      
      function onMouseMove(e) {
          if (isDrawing) {
              currentX = e.offsetX;
              currentY = e.offsetY;
              // Limpia solo la flecha actual, no todo el canvas
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              drawArrows();
              drawArrow(startX, startY, currentX, currentY);
          }
      }
      
      function onMouseUp(e) {
          if (isDrawing) {
              isDrawing = false;
              currentX = e.offsetX;
              currentY = e.offsetY;
              // Agrega la flecha al arreglo de flechas y desactiva el dibujo
              arrows.push({ fromX: startX, fromY: startY, toX: currentX, toY: currentY });
              drawArrows();
              drawingEnabled = false; // Deshabilita el dibujo después de dibujar una flecha
          }
      }
      
      function onMouseOut() {
          isDrawing = false;
      }
      
      // Dibuja una flecha en el lienzo
      function drawArrow(fromX, fromY, toX, toY) {
          // Dibuja la línea principal
          ctx.beginPath();
          ctx.moveTo(fromX, fromY);
          ctx.lineTo(toX, toY);
          ctx.stroke();
      
          // Calcular el ángulo de la línea
          const angle = Math.atan2(toY - fromY, toX - fromX);
      
          // Longitud de la cabeza de la flecha
          const headLength = 10;
      
          // Dibuja la cabeza de la flecha
          ctx.beginPath();
          ctx.moveTo(toX, toY);
          ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6), toY - headLength * Math.sin(angle - Math.PI / 6));
          ctx.moveTo(toX, toY);
          ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6), toY - headLength * Math.sin(angle + Math.PI / 6));
          ctx.stroke();
      }
      
      // Almacena todas las flechas dibujadas
      // Inicialización de la variable arrows
      arrows = [];
      
      // Redibuja todas las flechas en el lienzo
      function drawArrows() {
          ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpia el lienzo
          for (const arrow of arrows) {
              drawArrow(arrow.fromX, arrow.fromY, arrow.toX, arrow.toY);
          }
      }
      
      // Detección de clic en una flecha
      function onCanvasClick(e) {
          const x = e.offsetX;
          const y = e.offsetY;
          selectedArrowIndex = getClickedArrowIndex(x, y);
          if (selectedArrowIndex > -1) {
              deleteArrowButton.style.display = 'block';
          } else {
              deleteArrowButton.style.display = 'none';
          }
      }
      
      // Verifica si un punto está cerca de una línea
      function getClickedArrowIndex(x, y) {
          for (let i = 0; i < arrows.length; i++) {
              const arrow = arrows[i];
              if (isPointNearLine(x, y, arrow.fromX, arrow.fromY, arrow.toX, arrow.toY)) {
                  return i;
              }
          }
          return -1;
      }
      
      function isPointNearLine(px, py, x1, y1, x2, y2) {
          const distToPoint = distanceToSegment(px, py, x1, y1, x2, y2);
          return distToPoint < 5; // Define la proximidad a la línea
      }
      
      function distanceToSegment(px, py, x1, y1, x2, y2) {
          const l2 = (x2 - x1) ** 2 + (y2 - y1) ** 2;
          if (l2 === 0) return Math.hypot(px - x1, py - y1);
          let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
          t = Math.max(0, Math.min(1, t));
          return Math.hypot(px - (x1 + t * (x2 - x1)), py - (y1 + t * (y2 - y1)));
      }
      
      
      </script>
  </body>
</html>
